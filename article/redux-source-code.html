<!DOCTYPE html><html><head><meta name="keywords" content="前端,react,babel,ts,typescript,学习记录"/><meta name="description" content="学习和分享工作生活中遇到的问题，记录前沿的技术，分享技术文章。"/><meta name="google-site-verification" content="s-VsAQCdV_MrjX9LC-rvr6SZ-MYSM4y1vVMJ9Fw7Oxo"/><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Redux 源码解析</title><meta name="description" content="Redux 源码解析"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/cf2d2167c5644ef0de3a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cf2d2167c5644ef0de3a.css" data-n-g=""/><link rel="preload" href="/_next/static/css/2c29b5f4059231122a7f.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2c29b5f4059231122a7f.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="/_next/static/chunks/webpack-fb76148cfcfb42ca18eb.js" defer=""></script><script src="/_next/static/chunks/framework-895f067827ebe11ffe45.js" defer=""></script><script src="/_next/static/chunks/main-c4f2541b93e4ae8b71f8.js" defer=""></script><script src="/_next/static/chunks/pages/_app-472761f2aef6a4dd81fc.js" defer=""></script><script src="/_next/static/chunks/800-724b2f069f0c30072447.js" defer=""></script><script src="/_next/static/chunks/pages/article/redux-source-code-46b55230007201226796.js" defer=""></script><script src="/_next/static/E-yMlcZOffAX6cd0TJKvF/_buildManifest.js" defer=""></script><script src="/_next/static/E-yMlcZOffAX6cd0TJKvF/_ssgManifest.js" defer=""></script></head><script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><body class="dark"><div id="__next"><div class="Layout_layout__1EnHR"><div class="Header_header__3Hw3A"><h1 class="Header_title__2jGsC"><a href="/">BLOG ZHANG</a></h1><div class="Switch_switch__11c0w"><div class="Switch_switchWarp__1Gqov"><div class="Switch_switchLeft__3OCuZ"> <img src="/moon.png" alt="" width="16" height="16"/></div><div class="Switch_switchRigth__1Wjdr"><img src="/sun.png" alt="" width="16" height="16"/></div></div><div class="Switch_switchCheck__1aiIo Switch_dark__2WQ89"></div></div></div><div class="ImgPreview_imgPreview__2OxIp"><img src=""/></div><article class="post_article__2Kkhj"><h1>Redux 源码解析</h1>
<p>11 月 04, 2021 • ☕️☕️☕️ 80 min read</p>
<p>本文将由浅到深介绍 redux 及其辅助工具的使用及其原理，想写这篇文章很久了，今天终于抽出时间来记录一下，小伙伴们准备好了吗，发车！</p>
<h2>1、redux 的基本的使用</h2>
<p>先用官网的例子来介绍下 redux 的最基本的使用（使用在原生 js 中）</p>
<blockquote>
<p>注： 在阅读时，请先摒弃之前的使用习惯，不要去思考 react-redux，dva，saga 等用法，过度纠结辅助工具的语法只会让你对 redux 源码更加纠结，所以请先抛弃之前的使用语法，我们就从最原始的 redux 语法开始讲起。搭配 <a href="https://github.com/zlqxk/redux-source-code">代码</a> 食用更佳</p>
</blockquote>
<pre class="hljs"><code><span class="hljs-comment">//    ./src/index.jsx</span>
<span class="hljs-keyword">import</span> { createStore } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>
<span class="hljs-comment">// 创建reducer</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">counter</span>(<span class="hljs-params">state = <span class="hljs-number">0</span>, action</span>) {
  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;INCREMENT&#x27;</span>:
      <span class="hljs-keyword">return</span> state + <span class="hljs-number">1</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;DECREMENT&#x27;</span>:
      <span class="hljs-keyword">return</span> state - <span class="hljs-number">1</span>
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">return</span> state
  }
}
<span class="hljs-comment">// 传入创建的reducer并创建store</span>
<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(counter)
<span class="hljs-comment">// 手动订阅更新 (当dispatch时将会执行回调函数)</span>
store.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">() =&gt;</span>
  <span class="hljs-comment">// getState() 用来获取最新的state</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(store.<span class="hljs-title function_">getState</span>())
)
<span class="hljs-comment">/**
 * 派发action，每次派发action都会在reducer中进行匹配，然后返回对应的state
 * 在上面我们已经手动订阅了更新，所以每次派发action时，都会触发store.subscribe回调函数，然后将最新的state打印出来
 */</span>
store.<span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT&#x27;</span> })
store.<span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT&#x27;</span> })
store.<span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT&#x27;</span> })
</code></pre>
<p>短短几行代码就可以实现 redux 的基本功能，那上面的例子中都用到了哪几个 api 呢，有创建 store 的 createStore，和挂载在 store 上的订阅 subscribe，派发 action 的 dispatch，获取最新状态的 getState，那我们就先看下这几个是怎么实现的（可以直接在 node_module 中找到 redux 源码文件中的 es 文件夹下 redux.js 去 debugger）</p>
<hr>
<p>那我们就先看看 createStore 到底有什么玄机，由于 createStore 源码较长，我把他拆成几部分一点一点看</p>
<blockquote>
<p>我们可以看到 createStore 接收三个参数，我们上面的例子只传入了第一个参数 reducer。第二个参数是 preloadedState 是初始化状态，第三个参数是 enhancer，这个的作用是用来增强 dispatch 的能力</p>
</blockquote>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createStore</span>(<span class="hljs-params">reducer, preloadedState, enhancer</span>) {
  <span class="hljs-comment">// 一些类型判断。。。</span>
  <span class="hljs-keyword">if</span> (
    (<span class="hljs-keyword">typeof</span> preloadedState === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> enhancer === <span class="hljs-string">&#x27;function&#x27;</span>) ||
    (<span class="hljs-keyword">typeof</span> enhancer === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">3</span>] === <span class="hljs-string">&#x27;function&#x27;</span>)
  ) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
      <span class="hljs-string">&#x27;It looks like you are passing several store enhancers to &#x27;</span> +
        <span class="hljs-string">&#x27;createStore(). This is not supported. Instead, compose them &#x27;</span> +
        <span class="hljs-string">&#x27;together to a single function.&#x27;</span>
    )
  }
  <span class="hljs-comment">/**
   * 如果第二个参数传入的是一个函数，并且没有传入第三个参数，则把第二个参数赋值给第三个参数
   * 正是因为这样我们才可以这样写 createStore（reducer, applymiddleware(thunk))，直接省略
   * 第二个参数preloadedState
   */</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> preloadedState === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> enhancer === <span class="hljs-string">&#x27;undefined&#x27;</span>) {
    enhancer = preloadedState
    preloadedState = <span class="hljs-literal">undefined</span>
  }
  <span class="hljs-comment">// 一些类型判断</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> enhancer !== <span class="hljs-string">&#x27;undefined&#x27;</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> enhancer !== <span class="hljs-string">&#x27;function&#x27;</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Expected the enhancer to be a function.&#x27;</span>)
    }
    <span class="hljs-comment">// 接受中间件来增强dispatch的能力，在讲中间件的部分我们重点讲，现在可以先忽略</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">enhancer</span>(createStore)(reducer, preloadedState)
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> reducer !== <span class="hljs-string">&#x27;function&#x27;</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Expected the reducer to be a function.&#x27;</span>)
  }

  <span class="hljs-keyword">let</span> currentReducer = reducer <span class="hljs-comment">// 传入的reducer</span>
  <span class="hljs-keyword">let</span> currentState = preloadedState <span class="hljs-comment">// 传入的preloadedState，通常为undefined</span>
  <span class="hljs-keyword">let</span> currentListeners = [] <span class="hljs-comment">// 创建一个用来存放subscribe的数组，因为可以声明多个subscribe, 所以使用一个数组来维护</span>
  <span class="hljs-keyword">let</span> nextListeners = currentListeners <span class="hljs-comment">// 最新的存放订阅的数组</span>
  <span class="hljs-keyword">let</span> isDispatching = <span class="hljs-literal">false</span> <span class="hljs-comment">// 一个标志，用来判断是否是派发阶段，在同一时间里，只能触发一次action，如果同一时间触发了两个actoin，那数据就会紊乱，所以通过这个锁来控制同一时间只能触发一次action</span>
  <span class="hljs-comment">/** 
     * 用来确保nextListeners和currentListeners不是一个引用
     * 用来保证在订阅中添加订阅情况时能正常运行（可以自己在redux中把这里注释掉，然后看下有什么变化 :)，所以通过nextListeners和currentListeners共同维护订阅数组
      store.subscribe(() =&gt; {
        // getState() 用来获取最新的state
        console.log(store.getState())
        store.subscribe(() =&gt; {
          // getState() 用来获取最新的state
          console.log(store.getState(), &#x27;2&#x27;)
        });
      });
    */</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">ensureCanMutateNextListeners</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (nextListeners === currentListeners) {
      nextListeners = currentListeners.<span class="hljs-title function_">slice</span>()
    }
  }
  <span class="hljs-comment">/**
   * getState用来返回最新的状态，在上述的例子中我们正是在订阅的回调中调用了这个方法来打印最新的状态
   * console.log(store.getState())
   * 那返回的这个currentState是什么时候改变呢，在后面的dispatch里我们会讲到
   */</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getState</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (isDispatching) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
        <span class="hljs-string">&#x27;You may not call store.getState() while the reducer is executing. &#x27;</span> +
          <span class="hljs-string">&#x27;The reducer has already received the state as an argument. &#x27;</span> +
          <span class="hljs-string">&#x27;Pass it down from the top reducer instead of reading it from the store.&#x27;</span>
      )
    }
    <span class="hljs-keyword">return</span> currentState
  }
}
</code></pre>
<p>紧接上文，下面介绍 createStore 中的 subscribe 是怎么实现的</p>
<pre class="hljs"><code><span class="hljs-comment">// 可以看到这个subscribe这个方法只接受一个参数，我们上面的的例子传入了一个回调函数来打印最新的状态</span>
<span class="hljs-comment">// 再回忆下我们当时怎么使用的</span>
<span class="hljs-comment">// store.subscribe(() =&gt;</span>
<span class="hljs-comment">//   console.log(store.getState())</span>
<span class="hljs-comment">// );</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">listener</span>) {
  <span class="hljs-comment">// 只允许接受函数</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> listener !== <span class="hljs-string">&#x27;function&#x27;</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Expected the listener to be a function.&#x27;</span>)
  }
  <span class="hljs-comment">// 在reducer执行过程中不能执行订阅</span>
  <span class="hljs-keyword">if</span> (isDispatching) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
      <span class="hljs-string">&#x27;You may not call store.subscribe() while the reducer is executing. &#x27;</span> +
        <span class="hljs-string">&#x27;If you would like to be notified after the store has been updated, subscribe from a &#x27;</span> +
        <span class="hljs-string">&#x27;component and invoke store.getState() in the callback to access the latest state. &#x27;</span> +
        <span class="hljs-string">&#x27;See https://redux.js.org/api-reference/store#subscribelistener for more details.&#x27;</span>
    )
  }
  <span class="hljs-keyword">let</span> isSubscribed = <span class="hljs-literal">true</span>

  <span class="hljs-comment">// 用来确保nextListeners和currentListeners不是一个引用</span>
  <span class="hljs-title function_">ensureCanMutateNextListeners</span>()
  <span class="hljs-comment">/**
   * 将我们传入的回调函数push到nextListeners这个数组里，这样后续我们dispatch的时候就可以在这个数组里遍历
   * 找到我们的回调函数，然后执行它
   */</span>
  nextListeners.<span class="hljs-title function_">push</span>(listener)
  <span class="hljs-comment">// 返回一个用来卸载订阅的函数</span>
  <span class="hljs-comment">// 这样就可以卸载订阅</span>
  <span class="hljs-comment">// store.subscribe(() =&gt;</span>
  <span class="hljs-comment">//   console.log(store.getState())</span>
  <span class="hljs-comment">// )();</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">unsubscribe</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (!isSubscribed) {
      <span class="hljs-keyword">return</span>
    }
    <span class="hljs-keyword">if</span> (isDispatching) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
        <span class="hljs-string">&#x27;You may not unsubscribe from a store listener while the reducer is executing. &#x27;</span> +
          <span class="hljs-string">&#x27;See https://redux.js.org/api-reference/store#subscribelistener for more details.&#x27;</span>
      )
    }
    isSubscribed = <span class="hljs-literal">false</span>
    <span class="hljs-title function_">ensureCanMutateNextListeners</span>()
    <span class="hljs-keyword">const</span> index = nextListeners.<span class="hljs-title function_">indexOf</span>(listener)
    nextListeners.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>)
    currentListeners = <span class="hljs-literal">null</span>
  }
}
</code></pre>
<p>紧接上文我们介绍下 dispatch 是如何实现派发 action 的</p>
<pre class="hljs"><code><span class="hljs-comment">/**
 * 回忆下我们当时是怎么使用的
 * store.dispatch({ type: &quot;INCREMENT&quot; })
 * dispatch只接受一个参数actino，其中规范约定是一个包含type的对象
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-params">action</span>) {
  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isPlainObject</span>(action)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Actions must be plain objects. &#x27;</span> + <span class="hljs-string">&#x27;Use custom middleware for async actions.&#x27;</span>)
  }
  <span class="hljs-comment">/** 
      function isPlainObject(obj) {
        if (typeof obj !== &#x27;object&#x27; || obj === null) return false
        let proto = obj
        while (Object.getPrototypeOf(proto) !== null) {
          proto = Object.getPrototypeOf(proto)
        }
        return Object.getPrototypeOf(obj) === proto
      }
      * 该函数的作用是用来判断传入的acion是不是一个简单对象
      * 简单对象：new Object 或者 {} 声明的对象
      * isPlainObject({}) // true
      * class Per {}
      * var p = new Per()
      * isPlainObject(p) // false
    */</span>
  <span class="hljs-comment">// 判断是否有type来约束派发的acion必须包含type属性</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> action.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;undefined&#x27;</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
      <span class="hljs-string">&#x27;Actions may not have an undefined &quot;type&quot; property. &#x27;</span> + <span class="hljs-string">&#x27;Have you misspelled a constant?&#x27;</span>
    )
  }
  <span class="hljs-keyword">if</span> (isDispatching) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Reducers may not dispatch actions.&#x27;</span>)
  }
  <span class="hljs-keyword">try</span> {
    isDispatching = <span class="hljs-literal">true</span>
    currentState = <span class="hljs-title function_">currentReducer</span>(currentState, action)
  } <span class="hljs-keyword">finally</span> {
    isDispatching = <span class="hljs-literal">false</span>
  }
  <span class="hljs-comment">/** 
     * 上面这里就是精髓了
     * currentReducer就是我们创建store时传入的reducer
     * <span class="hljs-doctag">@params</span> currentState就是当前的状态，第一次是我们的默认参数state = 0，后续都是返回的最新的状态
     * <span class="hljs-doctag">@params</span> action = { type: &quot;INCREMENT&quot; }
     * 然后返回新的state给currentState
     * 还记不记得getState()这个函数，getState()这个函数的返回值正是currentState
     * 所以实现了每次派发一个action改变了state，然后通过getState()就能拿到最新的state
     * 例子中我们传入的reducer:
      function counter(state = 0, action) {
        switch (action.type) {
          case &quot;INCREMENT&quot;:
            return state + 1;
          case &quot;DECREMENT&quot;:
            return state - 1;
          default:
            return state;
        }
      }
    */</span>
  <span class="hljs-keyword">const</span> listeners = (currentListeners = nextListeners)
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; listeners.<span class="hljs-property">length</span>; i++) {
    <span class="hljs-keyword">const</span> listener = listeners[i]
    <span class="hljs-title function_">listener</span>()
  }
  <span class="hljs-comment">/** 
     * 为什么每当我们执行store.dispatch({ type: &quot;INCREMENT&quot; })，subscribe订阅的回调函数都会自动执行呢
     * 正是因为在subscribe这个函数里我们将要订阅的回调函数push到了nextListeners这个数组里
     * 然后在这里我们就可以遍历nextListeners这个数组来执行我们订阅的回调函数
      store.subscribe(() =&gt;
        console.log(store.getState())
      );
      store.dispatch({ type: &quot;INCREMENT&quot; })
    */</span>
  <span class="hljs-keyword">return</span> action
}
</code></pre>
<hr>
<p>以上就是 createStore 的核心部分，createStore 里最后还有两个不常用的函数，这里贴出来大体解释下</p>
<pre class="hljs"><code><span class="hljs-comment">// 通过条件判断之后，以达到替换reducer效果</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">replaceReducer</span>(<span class="hljs-params">nextReducer</span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nextReducer !== <span class="hljs-string">&#x27;function&#x27;</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Expected the nextReducer to be a function.&#x27;</span>)
  }
  currentReducer = nextReducer
  <span class="hljs-comment">// This action has a similiar effect to ActionTypes.INIT.</span>
  <span class="hljs-comment">// Any reducers that existed in both the new and old rootReducer</span>
  <span class="hljs-comment">// will receive the previous state. This effectively populates</span>
  <span class="hljs-comment">// the new state tree with any relevant data from the old one.</span>
  <span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-title class_">ActionTypes</span>.<span class="hljs-property">REPLACE</span> })
}
</code></pre>
<pre class="hljs"><code><span class="hljs-comment">// 这个函数是用来给开发者使用的，我们无法使用而且不需要掌握</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">observable</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> outerSubscribe = subscribe
  <span class="hljs-keyword">return</span> {
    <span class="hljs-comment">/**
     * The minimal observable subscription method.
     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} observer Any object that can be used as an observer.
     * The observer object should have a `next` method.
     * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">subscription</span>} An object with an `unsubscribe` method that can
     * be used to unsubscribe the observable from the store, and prevent further
     * emission of values from the observable.
     */</span>
    <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">observer</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> observer !== <span class="hljs-string">&#x27;object&#x27;</span> || observer === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Expected the observer to be an object.&#x27;</span>)
      }
      <span class="hljs-keyword">function</span> <span class="hljs-title function_">observeState</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">if</span> (observer.<span class="hljs-property">next</span>) {
          observer.<span class="hljs-title function_">next</span>(<span class="hljs-title function_">getState</span>())
        }
      }
      <span class="hljs-title function_">observeState</span>()
      <span class="hljs-keyword">const</span> unsubscribe = <span class="hljs-title function_">outerSubscribe</span>(observeState)
      <span class="hljs-keyword">return</span> { unsubscribe }
    },
    [$$observable]() {
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>
    },
  }
}
</code></pre>
<p>在 createStore 的结尾将这些方法暴露出来，这样我们就可以通过 store.xxx 来调用了</p>
<pre class="hljs"><code><span class="hljs-comment">// 这里redux默认派发了一个action用来初始化stateTree，ActionTypes.INIT这个其实就是一个随机的字符，用来触发reducer里的switch里的default的回调，返回初始化的状态，这次的dispatch不会触发订阅，因为订阅在store创建之后</span>
<span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-title class_">ActionTypes</span>.<span class="hljs-property">INIT</span> })
<span class="hljs-keyword">return</span> {
  dispatch,
  subscribe,
  getState,
  replaceReducer,
  [$$observable]: observable,
}
</code></pre>
<h2>2、combineReducers 的使用及解析</h2>
<p>以上就是最基础的 redux 使用及其源码，但是在我们的使用中，通常都是维护一个状态树，然后通过多个 reducer 来改变状态树，redux 提供了 combineReducers 这个 api 来帮助我们维护多个 reducer，先让我们看下基本的 combineReducers 的使用</p>
<pre class="hljs"><code><span class="hljs-comment">//   ./src/index2.jsx   提示：将webpack入口改为index2.jsx即可运行</span>
<span class="hljs-keyword">import</span> { createStore, combineReducers } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>
<span class="hljs-comment">// 创建多个reducer</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">counter</span>(<span class="hljs-params">state = <span class="hljs-number">0</span>, action</span>) {
  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;INCREMENT&#x27;</span>:
      <span class="hljs-keyword">return</span> state + <span class="hljs-number">1</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;DECREMENT&#x27;</span>:
      <span class="hljs-keyword">return</span> state - <span class="hljs-number">1</span>
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">return</span> state
  }
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">counter2</span>(<span class="hljs-params">state = <span class="hljs-number">0</span>, action</span>) {
  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;INCREMENT2&#x27;</span>:
      <span class="hljs-keyword">return</span> state + <span class="hljs-number">1</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;DECREMENT2&#x27;</span>:
      <span class="hljs-keyword">return</span> state - <span class="hljs-number">1</span>
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">return</span> state
  }
}
<span class="hljs-comment">// 这里我们可以看到combineReducers方法接受一个对象为参数，对象的value正是每一个reducer</span>
<span class="hljs-keyword">const</span> rootReducer = <span class="hljs-title function_">combineReducers</span>({
  counter,
  counter2,
})
<span class="hljs-comment">// 传入创建的reducer并创建store</span>
<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(rootReducer)
<span class="hljs-comment">// 手动订阅更新 (当dispatch action 将会执行回调函数)</span>
store.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">() =&gt;</span>
  <span class="hljs-comment">// getState() 用来获取最新的state</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(store.<span class="hljs-title function_">getState</span>())
)
<span class="hljs-comment">/**
 * 派发action，每次派发action都会在reducer中进行匹配，然后返回对应的state
 * 在上面我们已经手动订阅了更新，所以每次派发action时，都会触发store.subscribe回调函数，然后将最新的state打印出来
 */</span>
store.<span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT&#x27;</span> })
store.<span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT&#x27;</span> })
store.<span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT&#x27;</span> })
store.<span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT2&#x27;</span> })
store.<span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT2&#x27;</span> })
store.<span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT2&#x27;</span> })
<span class="hljs-comment">// 输出的结果</span>
<span class="hljs-comment">// {counter: 1, counter2: 0}</span>
<span class="hljs-comment">// {counter: 2, counter2: 0}</span>
<span class="hljs-comment">// {counter: 3, counter2: 0}</span>
<span class="hljs-comment">// {counter: 3, counter2: 1}</span>
<span class="hljs-comment">// {counter: 3, counter2: 2}</span>
<span class="hljs-comment">// {counter: 3, counter2: 3}</span>
</code></pre>
<p>上述的例子我们可以看到，createStore 这个方法接收的是合并的 rootReducer 为参数，并且 store.getState()返回的 state 变为了对象的形式{counter: 1, counter2: 0}，那 combineReducers 究竟做了什么，让我们来一探究竟！</p>
<pre class="hljs"><code><span class="hljs-comment">// 参数reducers 为我们传入的 {counter: function counter, counter2: function counter2}</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">combineReducers</span>(<span class="hljs-params">reducers</span>) {
  <span class="hljs-comment">// Object.keys方法返回对象的所有可枚举属性的数组</span>
  <span class="hljs-comment">// reducerKeys = [counter, counter2]</span>
  <span class="hljs-keyword">const</span> reducerKeys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(reducers)
  <span class="hljs-keyword">const</span> finalReducers = {}
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; reducerKeys.<span class="hljs-property">length</span>; i++) {
    <span class="hljs-keyword">const</span> key = reducerKeys[i]
    <span class="hljs-comment">// 如果在开发环境，会有一个报错提示</span>
    <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> reducers[key] === <span class="hljs-string">&#x27;undefined&#x27;</span>) {
        <span class="hljs-title function_">warning</span>(<span class="hljs-string">`No reducer provided for key &quot;<span class="hljs-subst">${key}</span>&quot;`</span>)
      }
    }

    <span class="hljs-comment">/**
     * 这里其实就是一个筛选的过程，如果我们传入的reducers参数是这种格式
     * {
     *    counter: function counter
     *    counter2: function counter2
     *    counter3: undefined
     * }
     * 那么将会把counter3过滤掉，返回的finalReducers为
     *
     * {
     *    counter: function counter
     *    counter2: function counter2
     * }
     */</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> reducers[key] === <span class="hljs-string">&#x27;function&#x27;</span>) {
      finalReducers[key] = reducers[key]
    }
  }

  <span class="hljs-keyword">const</span> finalReducerKeys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(finalReducers)
  <span class="hljs-comment">/**
   *  得到最终的finalReducerKeys和finalReducers
   *  finalReducerKeys = [&#x27;counter&#x27;, &#x27;counter2&#x27;]
   *  finalReducers = {
   *    counter: funtion counter,
   *    counter2: funtion counter2
   *  }
   */</span>
  <span class="hljs-keyword">let</span> unexpectedKeyCache
  <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span>) {
    unexpectedKeyCache = {}
  }
  <span class="hljs-comment">// 这里是做一个类型判断，这个函数的解析在下方，可以先移步下方assertReducerShape的解析</span>
  <span class="hljs-keyword">let</span> shapeAssertionError
  <span class="hljs-keyword">try</span> {
    <span class="hljs-title function_">assertReducerShape</span>(finalReducers)
  } <span class="hljs-keyword">catch</span> (e) {
    shapeAssertionError = e
  }
  <span class="hljs-comment">/** 
     * 精髓来了，combineReducers在经历了一系列的判断后，最终会返回一个函数combination
      const rootReducer = combineReducers({
        counter,
        counter2
      })
      const store = createStore(rootReducer);
     * 然后我们再将这个函数传入createStore
     * 大家还记得createStore接受的第一个参数吗，在没有使用combineReducers之前传入的是单个的reducer
     * 在使用了之后传入的是combination
     * 再回忆一下createStore中的dispatch函数，其中最主要的是下面这段
     * try {
        isDispatching = true
        currentState = currentReducer(currentState, action)
      } finally {
        isDispatching = false
      }
     * 现在的currentReducer正是combination
    */</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">combination</span>(<span class="hljs-params">state = {}, action</span>) {
    <span class="hljs-comment">// 结合上文的shapeAssertionError， 如果assertReducerShape里抛出了异常，那么在这里也会被阻塞</span>
    <span class="hljs-keyword">if</span> (shapeAssertionError) {
      <span class="hljs-keyword">throw</span> shapeAssertionError
    }
    <span class="hljs-comment">// 如果不是在生产环境下，做一些警告级别的错误</span>
    <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span>) {
      <span class="hljs-comment">// 这个函数的解析也在下方，可以先移步下方的getUnexpectedStateShapeWarningMessage解析</span>
      <span class="hljs-keyword">const</span> warningMessage = <span class="hljs-title function_">getUnexpectedStateShapeWarningMessage</span>(
        state, <span class="hljs-comment">// currentState</span>
        finalReducers, <span class="hljs-comment">// 多个reducer组成的对象</span>
        action, <span class="hljs-comment">// 传入的action</span>
        unexpectedKeyCache
      )
      <span class="hljs-keyword">if</span> (warningMessage) {
        <span class="hljs-title function_">warning</span>(warningMessage)
      }
    }

    <span class="hljs-comment">// 经过了一系列的判断以后，终于来到了精髓部分</span>
    <span class="hljs-keyword">let</span> hasChanged = <span class="hljs-literal">false</span>
    <span class="hljs-comment">// 这个nextState就是最终返回值</span>
    <span class="hljs-keyword">const</span> nextState = {}
    <span class="hljs-comment">// finalReducerKeys = [&#x27;counter&#x27;, &#x27;counter2&#x27;]</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; finalReducerKeys.<span class="hljs-property">length</span>; i++) {
      <span class="hljs-comment">// 为了方便大家理解，我们以i=0时刻为例，看一下每一个字段对应着什么</span>
      <span class="hljs-keyword">const</span> key = finalReducerKeys[i] <span class="hljs-comment">// &#x27;counter&#x27;</span>
      <span class="hljs-keyword">const</span> reducer = finalReducers[key] <span class="hljs-comment">// function counter</span>
      <span class="hljs-keyword">const</span> previousStateForKey = state[key] <span class="hljs-comment">// state就是currentState</span>
      <span class="hljs-comment">// 执行function counter，并且将最新的state赋值给nextStateForKey</span>
      <span class="hljs-keyword">const</span> nextStateForKey = <span class="hljs-title function_">reducer</span>(previousStateForKey, action)
      <span class="hljs-comment">// 做一次类型判断</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nextStateForKey === <span class="hljs-string">&#x27;undefined&#x27;</span>) {
        <span class="hljs-comment">// getUndefinedStateErrorMessage就是返回一段错误文案</span>
        <span class="hljs-keyword">const</span> errorMessage = <span class="hljs-title function_">getUndefinedStateErrorMessage</span>(key, action)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(errorMessage)
      }
      <span class="hljs-comment">// 将counter这次返回的最新的state赋值到nextState这个对象里，所以我们最后拿到的是{conuter: 1, counter: 2} 这种格式</span>
      nextState[key] = nextStateForKey
      <span class="hljs-comment">// hasChanged的作用是用来判断最新的状态与上一次的状态有没有发生改变，如果发生改变则为true</span>
      <span class="hljs-comment">// 并且这里有一个短路操作，只要多个reducer其中有一个状态发生了改变，则hasChanged为true</span>
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey
    }
    <span class="hljs-comment">// 如果所有的reducer都没有改变状态，则返回原来的状态，否则返回最新的状态</span>
    <span class="hljs-comment">// 这里就有疑问了，为什么要做这个判断，无论有没有发生改变直接返回最新的状态不就可以了吗</span>
    <span class="hljs-comment">// 个人理解这里之所以要做这个判断，是因为在状态没有改变的情况，还是返回之前的引用，就不必再开辟新的引用来存储</span>
    <span class="hljs-comment">// 新的状态，只有状态发生改变，才去返回最新的引用</span>
    hasChanged = hasChanged || finalReducerKeys.<span class="hljs-property">length</span> !== <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(state).<span class="hljs-property">length</span>
    <span class="hljs-keyword">return</span> hasChanged ? nextState : state
  }
}
</code></pre>
<p>assertReducerShape 解析，主要作用是保证你的 reducer 都是正常可运行的</p>
<pre class="hljs"><code><span class="hljs-comment">// 入参reducers为</span>
<span class="hljs-comment">// {</span>
<span class="hljs-comment">//   counter: funtion counter,</span>
<span class="hljs-comment">//   counter2: funtion counter2</span>
<span class="hljs-comment">// }</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">assertReducerShape</span>(<span class="hljs-params">reducers</span>) {
  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(reducers).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> reducer = reducers[key]
    <span class="hljs-comment">// 这一步相当于redux手动派发了一次action，ActionTypes.INIT在上文讲过，就是是一个随机的字符串，用来触发reducer里switch判断的defalut</span>
    <span class="hljs-comment">// default:</span>
    <span class="hljs-comment">//   return state;</span>
    <span class="hljs-comment">// 如果在reducer函数里没有写defalut，或者在default里没有返回state， 那么将会抛出下面的异常</span>
    <span class="hljs-keyword">const</span> initialState = <span class="hljs-title function_">reducer</span>(<span class="hljs-literal">undefined</span>, { <span class="hljs-attr">type</span>: <span class="hljs-title class_">ActionTypes</span>.<span class="hljs-property">INIT</span> })
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> initialState === <span class="hljs-string">&#x27;undefined&#x27;</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
        <span class="hljs-string">`Reducer &quot;<span class="hljs-subst">${key}</span>&quot; returned undefined during initialization. `</span> +
          <span class="hljs-string">`If the state passed to the reducer is undefined, you must `</span> +
          <span class="hljs-string">`explicitly return the initial state. The initial state may `</span> +
          <span class="hljs-string">`not be undefined. If you don&#x27;t want to set a value for this reducer, `</span> +
          <span class="hljs-string">`you can use null instead of undefined.`</span>
      )
    }
    <span class="hljs-comment">// 这里是确保不能占用redux内部特有的命名空间 redux/*</span>
    <span class="hljs-keyword">if</span> (
      <span class="hljs-keyword">typeof</span> <span class="hljs-title function_">reducer</span>(<span class="hljs-literal">undefined</span>, {
        <span class="hljs-attr">type</span>: <span class="hljs-title class_">ActionTypes</span>.<span class="hljs-title function_">PROBE_UNKNOWN_ACTION</span>(),
      }) === <span class="hljs-string">&#x27;undefined&#x27;</span>
    ) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
        <span class="hljs-string">`Reducer &quot;<span class="hljs-subst">${key}</span>&quot; returned undefined when probed with a random type. `</span> +
          <span class="hljs-string">`Don&#x27;t try to handle <span class="hljs-subst">${ActionTypes.INIT}</span> or other actions in &quot;redux/*&quot; `</span> +
          <span class="hljs-string">`namespace. They are considered private. Instead, you must return the `</span> +
          <span class="hljs-string">`current state for any unknown actions, unless it is undefined, `</span> +
          <span class="hljs-string">`in which case you must return the initial state, regardless of the `</span> +
          <span class="hljs-string">`action type. The initial state may not be undefined, but can be null.`</span>
      )
    }
  })
}
</code></pre>
<p>getUnexpectedStateShapeWarningMessage 解析，主要是一些警告错误，判断 reducers 是否为空，inputState 是否是简单对象等</p>
<pre class="hljs"><code><span class="hljs-comment">/**
 * <span class="hljs-doctag">@params</span> inputState 也就是currentState
 * <span class="hljs-doctag">@params</span> reducers 也就是finalReducers
 * <span class="hljs-doctag">@params</span> <span class="hljs-variable">action</span>
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getUnexpectedStateShapeWarningMessage</span>(<span class="hljs-params">inputState, reducers, action, unexpectedKeyCache</span>) {
  <span class="hljs-comment">// 国际惯例，还是先取出多个reducers属性组成的数组 reducerKeys = [&#x27;counter&#x27;, &#x27;counter2&#x27;]</span>
  <span class="hljs-keyword">const</span> reducerKeys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(reducers)
  <span class="hljs-keyword">const</span> argumentName =
    <span class="hljs-comment">// 这块其实就是根据action.type来确定报错时候的文案</span>
    action &amp;&amp; action.<span class="hljs-property">type</span> === <span class="hljs-title class_">ActionTypes</span>.<span class="hljs-property">INIT</span>
      ? <span class="hljs-string">&#x27;preloadedState argument passed to createStore&#x27;</span>
      : <span class="hljs-string">&#x27;previous state received by the reducer&#x27;</span>
  <span class="hljs-comment">// 至少要有一个reducer</span>
  <span class="hljs-keyword">if</span> (reducerKeys.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> (
      <span class="hljs-string">&#x27;Store does not have a valid reducer. Make sure the argument passed &#x27;</span> +
      <span class="hljs-string">&#x27;to combineReducers is an object whose values are reducers.&#x27;</span>
    )
  }
  <span class="hljs-comment">// 这个地方判断第一个参数inputState是不是一个简单对象</span>
  <span class="hljs-comment">// 这个时候机智的小伙伴就已经发现，我们对currentState的判断已经变成了一个简单对象</span>
  <span class="hljs-comment">// 回忆一下，store.getState()返回的数据格式 {counter: 3, counter2: 3}</span>
  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isPlainObject</span>(inputState)) {
    <span class="hljs-keyword">return</span> (
      <span class="hljs-string">`The <span class="hljs-subst">${argumentName}</span> has unexpected type of &quot;`</span> +
      {}.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(inputState).<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\s([a-z|A-Z]+)/</span>)[<span class="hljs-number">1</span>] +
      <span class="hljs-string">`&quot;. Expected argument to be an object with the following `</span> +
      <span class="hljs-string">`keys: &quot;<span class="hljs-subst">${reducerKeys.join(<span class="hljs-string">&#x27;&quot;, &quot;&#x27;</span>)}</span>&quot;`</span>
    )
  }
  <span class="hljs-comment">// 以下操作主要是用来确保有没有不合理的key</span>
  <span class="hljs-keyword">const</span> unexpectedKeys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(inputState).<span class="hljs-title function_">filter</span>(
    <span class="hljs-comment">// reducers.hasOwnProperty(key)用来判断对象reducers里有没有属性key</span>
    <span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> !reducers.<span class="hljs-title function_">hasOwnProperty</span>(key) &amp;&amp; !unexpectedKeyCache[key]
  )
  unexpectedKeys.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> {
    unexpectedKeyCache[key] = <span class="hljs-literal">true</span>
  })
  <span class="hljs-keyword">if</span> (action &amp;&amp; action.<span class="hljs-property">type</span> === <span class="hljs-title class_">ActionTypes</span>.<span class="hljs-property">REPLACE</span>) <span class="hljs-keyword">return</span>
  <span class="hljs-keyword">if</span> (unexpectedKeys.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> (
      <span class="hljs-string">`Unexpected <span class="hljs-subst">${unexpectedKeys.length &gt; <span class="hljs-number">1</span> ? <span class="hljs-string">&#x27;keys&#x27;</span> : <span class="hljs-string">&#x27;key&#x27;</span>}</span> `</span> +
      <span class="hljs-string">`&quot;<span class="hljs-subst">${unexpectedKeys.join(<span class="hljs-string">&#x27;&quot;, &quot;&#x27;</span>)}</span>&quot; found in <span class="hljs-subst">${argumentName}</span>. `</span> +
      <span class="hljs-string">`Expected to find one of the known reducer keys instead: `</span> +
      <span class="hljs-string">`&quot;<span class="hljs-subst">${reducerKeys.join(<span class="hljs-string">&#x27;&quot;, &quot;&#x27;</span>)}</span>&quot;. Unexpected keys will be ignored.`</span>
    )
  }
}
</code></pre>
<h2>3、combineReducers 进阶用法及其解析</h2>
<p>在使用中我们通常会声明一个初始化对象，然后把这个对象传给不同的 reducer，由于声明的初始化对象是一个引用数据类型，在使用这我们就会发现一些问题，看下面的例子</p>
<pre class="hljs"><code><span class="hljs-comment">//  ./src/index3.jsx</span>
<span class="hljs-keyword">import</span> { createStore, combineReducers } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>
<span class="hljs-keyword">const</span> count = {
  <span class="hljs-attr">num</span>: <span class="hljs-number">0</span>,
}
<span class="hljs-keyword">const</span> count2 = {
  <span class="hljs-attr">num2</span>: <span class="hljs-number">0</span>,
}
<span class="hljs-comment">// 错误用法</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleData</span> = (<span class="hljs-params">state, type</span>) =&gt; {
  state[type] += <span class="hljs-number">1</span>
  <span class="hljs-keyword">return</span> state
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">counter</span>(<span class="hljs-params">state = count, action</span>) {
  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;INCREMENT&#x27;</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">handleData</span>(state, <span class="hljs-string">&#x27;num&#x27;</span>)
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">return</span> state
  }
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">counter2</span>(<span class="hljs-params">state = count2, action</span>) {
  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;INCREMENT2&#x27;</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">handleData</span>(state, <span class="hljs-string">&#x27;num2&#x27;</span>)
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">return</span> state
  }
}
<span class="hljs-keyword">const</span> rootReducer = <span class="hljs-title function_">combineReducers</span>({
  counter,
  counter2,
})
<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(rootReducer)
store.<span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT&#x27;</span> })
<span class="hljs-keyword">const</span> a = store.<span class="hljs-title function_">getState</span>()
store.<span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT&#x27;</span> })
<span class="hljs-keyword">const</span> b = store.<span class="hljs-title function_">getState</span>()
store.<span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT2&#x27;</span> })
<span class="hljs-keyword">const</span> c = store.<span class="hljs-title function_">getState</span>()
store.<span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT2&#x27;</span> })
<span class="hljs-keyword">const</span> d = store.<span class="hljs-title function_">getState</span>()
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, <span class="hljs-string">&#x27;a&#x27;</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b, <span class="hljs-string">&#x27;b&#x27;</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c, <span class="hljs-string">&#x27;b&#x27;</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d, <span class="hljs-string">&#x27;d&#x27;</span>)
</code></pre>
<p>思考一下，最后的四个 console 打印结果是什么呢，我们期望的是依次打印出每次的 dispatch 修改后的 state，结果四次打印的都是{counter: {num: 2}, counter2: {num2: 2}}，那怎样去实现期望的效果呢，第一种方法，对 state 做一层深拷贝，我们只需要改写一下 handleData 即可</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleData</span> = (<span class="hljs-params">state, type</span>) =&gt; {
  state = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>({}, state, {
    [type]: state[type] + <span class="hljs-number">1</span>,
  })
  <span class="hljs-keyword">return</span> state
}
<span class="hljs-comment">// 或者使用展开运算符</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleData</span> = (<span class="hljs-params">state, type</span>) =&gt; {
  <span class="hljs-keyword">return</span> { ...state, [type]: state[type] + <span class="hljs-number">1</span> }
}
</code></pre>
<p>3.1、使用 immutable 对象</p>
<p>但是这样还是不够优雅，如果初始化的 state 是多层的对象，只是一层的深拷贝的 Object.assign 和展开运算符就失效了，如果直接使用深层次的 deepClone，在数据量大的时候又会有性能问题，这时候 immutable 对象就排上用场了，immutable 声明的数据被视为不可变的，任何添加、删除、修改操作都会生成一个新的对象，这时候小伙伴又有疑问了，那这和深拷贝有什么区别呢，immutable 实现的原理是持久化数据结构共享，即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享，看下面的动图就方便理解 immutable 对象了</p>
<p><img src="/redux-source-code/immutable.gif" alt="持久化数据结构共享"></p>
<p>immutable 通过 set 和 get 来进行赋值和取值操作，immutable 的具体语法小伙伴请自行查阅[资料]哦(https://www.npmjs.com/package/immutable), 那我们来看看如何在 redux 中使用不可变对象吧，先来看一下不使用 combineReducer 的情况。</p>
<pre class="hljs"><code><span class="hljs-comment">// ./src/index4.jsx</span>
<span class="hljs-keyword">import</span> { createStore } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>
<span class="hljs-keyword">import</span> { fromJS } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;immutable&#x27;</span>
<span class="hljs-keyword">const</span> initState = {
  <span class="hljs-attr">num</span>: <span class="hljs-number">0</span>,
}
<span class="hljs-comment">// 使用formJS来将js对象转换为immutable对象</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">counter</span>(<span class="hljs-params">state = fromJS(initState), action</span>) {
  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;INCREMENT&#x27;</span>:
      <span class="hljs-keyword">return</span> state.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;num&#x27;</span>, state.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;num&#x27;</span>) + <span class="hljs-number">1</span>)
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">return</span> state
  }
}
<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(counter)
store.<span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT&#x27;</span> })
<span class="hljs-keyword">const</span> a = store.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;num&#x27;</span>)
store.<span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT&#x27;</span> })
<span class="hljs-keyword">const</span> b = store.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;num&#x27;</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, <span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-comment">// 1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b, <span class="hljs-string">&#x27;b&#x27;</span>) <span class="hljs-comment">// 2</span>
</code></pre>
<h3>3.2、redux-immutable 的使用和解析</h3>
<p>可以看到我们实现了预期的效果，但是，如果我们要使用 combineReducer 就会出现问题，redux 提供的 combineReducer 方法我们上面也阅读过了，只能处理 js 对象，如果把 immutable 对象与 redux 提供的 combineReducer 一起使用，就会出现外层是 js 对象，内层是 immutable 对象的情况，这显然不是我们想要的，由于很多开发者采用了 Immutable.js，所以也有很多类似的辅助工具，例如 redux-immutable。这个第三方包实现了一个能够处理 Immutable Map 数据而非普通的 JavaScript 对象的 combineReducers</p>
<pre class="hljs"><code><span class="hljs-comment">// ./src/index5.jsx</span>
<span class="hljs-keyword">import</span> { createStore } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>
<span class="hljs-keyword">import</span> { fromJS } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;immutable&#x27;</span>
<span class="hljs-keyword">import</span> { combineReducers } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-immutable&#x27;</span>
<span class="hljs-keyword">const</span> count = {
  <span class="hljs-attr">num</span>: <span class="hljs-number">0</span>,
}
<span class="hljs-keyword">const</span> count2 = {
  <span class="hljs-attr">num2</span>: <span class="hljs-number">0</span>,
}
<span class="hljs-comment">// 使用formJS来将js对象转换为immutable对象</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">counter</span>(<span class="hljs-params">state = fromJS(count), action</span>) {
  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;INCREMENT&#x27;</span>:
      <span class="hljs-keyword">return</span> state.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;num&#x27;</span>, state.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;num&#x27;</span>) + <span class="hljs-number">1</span>)
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">return</span> state
  }
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">counter2</span>(<span class="hljs-params">state = fromJS(count2), action</span>) {
  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;INCREMENT2&#x27;</span>:
      <span class="hljs-keyword">return</span> state.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;num2&#x27;</span>, state.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;num2&#x27;</span>) + <span class="hljs-number">1</span>)
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">return</span> state
  }
}
<span class="hljs-keyword">const</span> rootReducer = <span class="hljs-title function_">combineReducers</span>({
  counter,
  counter2,
})
<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(rootReducer)
store.<span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT&#x27;</span> })
<span class="hljs-keyword">const</span> a = store.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">getIn</span>([<span class="hljs-string">&#x27;counter&#x27;</span>, <span class="hljs-string">&#x27;num&#x27;</span>])
store.<span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT&#x27;</span> })
<span class="hljs-keyword">const</span> b = store.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">getIn</span>([<span class="hljs-string">&#x27;counter&#x27;</span>, <span class="hljs-string">&#x27;num&#x27;</span>])
store.<span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT2&#x27;</span> })
<span class="hljs-keyword">const</span> c = store.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">getIn</span>([<span class="hljs-string">&#x27;counter2&#x27;</span>, <span class="hljs-string">&#x27;num2&#x27;</span>])
store.<span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT2&#x27;</span> })
<span class="hljs-keyword">const</span> d = store.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">getIn</span>([<span class="hljs-string">&#x27;counter2&#x27;</span>, <span class="hljs-string">&#x27;num2&#x27;</span>])
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, <span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-comment">// 1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b, <span class="hljs-string">&#x27;b&#x27;</span>) <span class="hljs-comment">// 2</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c, <span class="hljs-string">&#x27;c&#x27;</span>) <span class="hljs-comment">// 1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d, <span class="hljs-string">&#x27;d&#x27;</span>) <span class="hljs-comment">// 2</span>
</code></pre>
<p>通过 redux-immutable 我们又可以得到一个完整的 immutable 对象了，那 redux-immutable 和 redux 提供的 combineReducer 有什么区别呢，让我们来看一下 redux-immutable 的 combineReducer<a href="https://github.com/gajus/redux-immutable/blob/master/src/combineReducers.js">源码</a></p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> <span class="hljs-title class_">Immutable</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;immutable&#x27;</span>
<span class="hljs-keyword">import</span> { getUnexpectedInvocationParameterMessage, validateNextState } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./utilities&#x27;</span>
<span class="hljs-comment">/**
 * <span class="hljs-doctag">@params</span> reducers 我们传入的reducer
 * <span class="hljs-doctag">@params</span> getDefaultState 比redux combineReducer多了一个默认状态的参数，但是通常我们也不使用他
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (<span class="hljs-attr">reducers</span>: <span class="hljs-title class_">Object</span>, <span class="hljs-attr">getDefaultState</span>: ?<span class="hljs-title class_">Function</span> = <span class="hljs-title class_">Immutable</span>.<span class="hljs-property">Map</span>): <span class="hljs-function"><span class="hljs-params">Function</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> reducerKeys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(reducers)
  <span class="hljs-keyword">return</span> (<span class="hljs-attr">inputState</span>: ?<span class="hljs-title class_">Function</span> = <span class="hljs-title function_">getDefaultState</span>(), <span class="hljs-attr">action</span>: <span class="hljs-title class_">Object</span>): <span class="hljs-title class_">Immutable</span>.<span class="hljs-property">Map</span> =&gt; {
    <span class="hljs-comment">// 与之前的一样，在开发环境下会做一些类型校验</span>
    <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span>) {
      <span class="hljs-keyword">const</span> warningMessage = <span class="hljs-title function_">getUnexpectedInvocationParameterMessage</span>(inputState, reducers, action)
      <span class="hljs-keyword">if</span> (warningMessage) {
        <span class="hljs-comment">// eslint-disable-next-line no-console</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(warningMessage)
      }
    }
    <span class="hljs-comment">//withMutations 主要用来提升性能，将需要多次创建的Imutable合并成一次。主要使用在需要对imutable 需要进行多次中间操作，最终返回一个Imutable的情况下</span>
    <span class="hljs-keyword">return</span> inputState.<span class="hljs-title function_">withMutations</span>(<span class="hljs-function">(<span class="hljs-params">temporaryState</span>) =&gt;</span> {
      <span class="hljs-comment">// 这块就和redux combineReducer基本一样了，只不过把对js对象的操作方法转换为了immutable的api</span>
      reducerKeys.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">reducerName</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> reducer = reducers[reducerName]
        <span class="hljs-keyword">const</span> currentDomainState = temporaryState.<span class="hljs-title function_">get</span>(reducerName)
        <span class="hljs-keyword">const</span> nextDomainState = <span class="hljs-title function_">reducer</span>(currentDomainState, action)
        <span class="hljs-title function_">validateNextState</span>(nextDomainState, reducerName, action)
        <span class="hljs-comment">/** 
             * validateNextState这个函数的作用也就是一个类型校验
              export default (nextState, reducerName: string, action: Object): void =&gt; {
                if (nextState === undefined) {
                  throw new Error(&#x27;Reducer &quot;&#x27; + reducerName + &#x27;&quot; returned undefined when handling &quot;&#x27; + action.type + &#x27;&quot; action. To ignore an action, you must explicitly return the previous state.&#x27;);
                }
              };
            */</span>
        temporaryState.<span class="hljs-title function_">set</span>(reducerName, nextDomainState)
      })
    })
  }
}
</code></pre>
<p>在理解了 redux combineReducer 的源码以后再来看 redux-immutable 其实很好理解了，主流程与 redux combineReducer 一致，只不过是把对 js 对象的操作方法转换为了 immutable 的 api。</p>
<h2>4、bindActionCreators 用法及其解析</h2>
<p>看到这里有的小伙伴会问，为什么上面的例子里派发 action 都是用的 store.dispatch，而在实际应用的时候好像很少这样写，通常都是以函数的形式来派发 action 呢？这就是 bindActionCreators 的功劳了，bindActionCreators 会对每个 action creator 进行包装，以便可以直接调用它们，那我们通过例子 🌰 来看一下 bindActionCreators 如何使用</p>
<pre class="hljs"><code><span class="hljs-comment">//   ./src/index6.jsx</span>
<span class="hljs-keyword">import</span> { createStore, bindActionCreators } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>
<span class="hljs-keyword">const</span> initState = {
  <span class="hljs-attr">num1</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">num2</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">num3</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">num4</span>: <span class="hljs-number">0</span>,
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">counter</span>(<span class="hljs-params">state = initState, action</span>) {
  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ADD_NUM1&#x27;</span>:
      <span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">num1</span>: state.<span class="hljs-property">num1</span> + <span class="hljs-number">1</span> }
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ADD_NUM2&#x27;</span>:
      <span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">num2</span>: state.<span class="hljs-property">num2</span> + <span class="hljs-number">1</span> }
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ADD_NUM3&#x27;</span>:
      <span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">num3</span>: state.<span class="hljs-property">num3</span> + <span class="hljs-number">1</span> }
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ADD_NUM4&#x27;</span>:
      <span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">num4</span>: state.<span class="hljs-property">num4</span> + <span class="hljs-number">1</span> }
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">return</span> state
  }
}
<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(counter)
<span class="hljs-comment">// 声明了四个的action creator，返回值就是要派发的action</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">ADD_NUM1</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ADD_NUM1&#x27;</span>,
  }
}
<span class="hljs-keyword">const</span> <span class="hljs-title function_">ADD_NUM2</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ADD_NUM2&#x27;</span>,
  }
}
<span class="hljs-keyword">const</span> <span class="hljs-title function_">ADD_NUM3</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ADD_NUM3&#x27;</span>,
  }
}
<span class="hljs-keyword">const</span> <span class="hljs-title function_">ADD_NUM4</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ADD_NUM4&#x27;</span>,
  }
}
<span class="hljs-comment">/**
 * bindActionCreators(actionCreators, dispatch)
 * 这个方法接受两个参数
 * actionCreators： 一个 action creator，或者一个 value 是 action creator 的对象。
 * dispatch： 一个由 Store 实例提供的 dispatch 函数。
 */</span>
<span class="hljs-keyword">const</span> boundActionCreators = <span class="hljs-title function_">bindActionCreators</span>(
  {
    <span class="hljs-variable constant_">ADD_NUM1</span>,
    <span class="hljs-variable constant_">ADD_NUM2</span>,
    <span class="hljs-variable constant_">ADD_NUM3</span>,
    <span class="hljs-variable constant_">ADD_NUM4</span>,
  },
  store.<span class="hljs-property">dispatch</span>
)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(boundActionCreators)
<span class="hljs-comment">// 这样就可以通过下面的方式调用了</span>
boundActionCreators.<span class="hljs-title function_">ADD_NUM1</span>()
boundActionCreators.<span class="hljs-title function_">ADD_NUM2</span>()
boundActionCreators.<span class="hljs-title function_">ADD_NUM3</span>()
boundActionCreators.<span class="hljs-title function_">ADD_NUM4</span>()
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(store.<span class="hljs-title function_">getState</span>())
</code></pre>
<p>注：唯一会使用到 bindActionCreators 的场景是当你需要把 action creator 往下传到一个组件上，却不想让这个组件觉察到 Redux 的存在，而且不希望把 dispatch 或 Redux store 传给它。当然你也可以在任何场景下使用。:) ，那接下来让我们看一下 bindActionCreators 是怎样帮我们做到派发 action 的.</p>
<pre class="hljs"><code><span class="hljs-comment">/**
 * actionCreators： 一个 action creator，或者一个 value 是 action creator 的对象。
 * dispatch： 一个由 Store 实例提供的 dispatch 函数。
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bindActionCreators</span>(<span class="hljs-params">actionCreators, dispatch</span>) {
  <span class="hljs-comment">// 如果我们只传入了一个action creator，返回bindActionCreator这个函数的返回值（这个函数我把他放在了下面）</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> actionCreators === <span class="hljs-string">&#x27;function&#x27;</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">bindActionCreator</span>(actionCreators, dispatch)
  }
  <span class="hljs-comment">// 国际惯例</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> actionCreators !== <span class="hljs-string">&#x27;object&#x27;</span> || actionCreators === <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
      <span class="hljs-string">`bindActionCreators expected an object or a function, instead received <span class="hljs-subst">${
        actionCreators === <span class="hljs-literal">null</span> ? <span class="hljs-string">&#x27;null&#x27;</span> : <span class="hljs-keyword">typeof</span> actionCreators
      }</span>. `</span> +
        <span class="hljs-string">`Did you write &quot;import ActionCreators from&quot; instead of &quot;import * as ActionCreators from&quot;?`</span>
    )
  }
  <span class="hljs-comment">// 如果我们传入actionCreators的是一个action creator 的对象，那么就循环遍历这个对象，然后把每一个元素都转换成bindActionCreator</span>
  <span class="hljs-keyword">const</span> boundActionCreators = {}
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> actionCreators) {
    <span class="hljs-keyword">const</span> actionCreator = actionCreators[key]
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> actionCreator === <span class="hljs-string">&#x27;function&#x27;</span>) {
      boundActionCreators[key] = <span class="hljs-title function_">bindActionCreator</span>(actionCreator, dispatch)
    }
  }
  <span class="hljs-keyword">return</span> boundActionCreators
}
<span class="hljs-comment">/**
 * 如果bindActionCreators第一个参数只传入了一个 action creator，将会返回下面这个函数
 * actionCreator： 传入的 action creator
 * dispatch： store.dispatch
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">bindActionCreator</span>(<span class="hljs-params">actionCreator, dispatch</span>) {
  <span class="hljs-comment">// 这个其实很好理解，dispatch就是store.dispatch</span>
  <span class="hljs-comment">// actionCreator.apply(this, arguments)这个其实就是调用了我们声明的action creator，返回值也就是 {type: xxxxx}</span>
  <span class="hljs-comment">// 这样就实现了只要我们调用ADD_NUM就相当于执行了store.dispatch({type:xxxxx})</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">dispatch</span>(actionCreator.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>))
  }
}
</code></pre>
<p>bindActionCreators 很巧妙的将 dispatch({type:xxx})的格式转换成了我们熟悉的函数的形式，并且如果应用在 react 中时，我们可以直接把这个函数传到子组件，这样子组件并不会感知到 redux</p>
<h2>5、applyMiddleware 的使用和解析</h2>
<p>在讲中间件之前我们先看一下 redux 提供给我们的一个工具函数 compose</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">compose</span>(<span class="hljs-params">...funcs</span>) {
  <span class="hljs-keyword">if</span> (funcs.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> arg
  }
  <span class="hljs-keyword">if</span> (funcs.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> funcs[<span class="hljs-number">0</span>]
  }
  <span class="hljs-keyword">return</span> funcs.<span class="hljs-title function_">reduce</span>(
    <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span>
      <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span>
        <span class="hljs-title function_">a</span>(<span class="hljs-title function_">b</span>(...args))
  )
}
</code></pre>
<p>这个函数有什么作用呢，让我们执行以下看看</p>
<pre class="hljs"><code><span class="hljs-comment">//   ./src/index7.jsx</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">compose</span>(<span class="hljs-params">...funcs</span>) {
  <span class="hljs-keyword">if</span> (funcs.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> arg
  }
  <span class="hljs-keyword">if</span> (funcs.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> funcs[<span class="hljs-number">0</span>]
  }
  <span class="hljs-keyword">return</span> funcs.<span class="hljs-title function_">reduce</span>(
    <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span>
      <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span>
        <span class="hljs-title function_">a</span>(<span class="hljs-title function_">b</span>(...args))
  )
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">func1</span>(<span class="hljs-params">arg</span>) {
  <span class="hljs-keyword">return</span> arg + <span class="hljs-number">1</span>
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">func2</span>(<span class="hljs-params">arg</span>) {
  <span class="hljs-keyword">return</span> arg + <span class="hljs-number">1</span>
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">func3</span>(<span class="hljs-params">arg</span>) {
  <span class="hljs-keyword">return</span> arg + <span class="hljs-number">1</span>
}
<span class="hljs-keyword">const</span> res = <span class="hljs-title function_">func1</span>(<span class="hljs-title function_">func2</span>(<span class="hljs-title function_">func3</span>(<span class="hljs-number">1</span>)))
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res, <span class="hljs-string">&#x27;res&#x27;</span>) <span class="hljs-comment">// 4</span>
<span class="hljs-keyword">const</span> composeFun = <span class="hljs-title function_">compose</span>(func1, func2, func3)
<span class="hljs-keyword">const</span> res2 = <span class="hljs-title function_">composeFun</span>(<span class="hljs-number">1</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res2, <span class="hljs-string">&#x27;res2&#x27;</span>) <span class="hljs-comment">// 4</span>
</code></pre>
<p>可以看到我们将 func1(func2(func3(1)))这种格式转换成了 compose(func1, func2, func3)(1)，这种写法有两个优点。</p>
<ul>
<li>1、就是防止函数左边化，使代码更加清晰</li>
<li>2、如果我们不知道有多少个函数嵌套调用的时候，使用 compose 就比较方便了，例如我们在使用 redux 时可能会传入多个中间件函数，compose 可以把所有的中间件当做参数传入，就可以实现中间件的嵌套使用了</li>
</ul>
<p>在介绍 applyMiddleware 之前，我们需要了解一下中间件的心智模型，redux 官网<a href="https://www.redux.org.cn/docs/advanced/Middleware.html">中间件篇</a>将带领我们一步一步的理解 Middleware，他会带领你从简单的函数封装到编写一个简单的中间件，我相信当你耐心看完这边文章以后一定会对中间件有了更加深刻的理解，这时我们就可以来看一下 applyMiddleware 是怎样实现的了。</p>
<p>注：这篇文章写得特别好，没有看过这篇文章的小伙伴一定要多琢磨几遍，这里再推荐一下 Dan Abramov 的个人<a href="https://overreacted.io/">博客</a>，每一篇都是满满的干货（而且大部分篇章都有中文翻译），其中<a href="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/">useEffect 完整指南</a>完整的讲述了函数式组件的心智模型，推荐大家阅读一下</p>
<p>在讲 applyMiddleware 之前我们先看一下 applyMiddleware 是如何使用的</p>
<pre class="hljs"><code><span class="hljs-comment">//    ./src/index8.jsx</span>
<span class="hljs-keyword">import</span> { createStore, applyMiddleware } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>
<span class="hljs-comment">/**
 * 记录所有被发起的 action 以及产生的新的 state。的中间件
 * 相信大家在读完redux官网的文章以后肯定可以理解下面这个中间件函数
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">logger</span> = (<span class="hljs-params">store</span>) =&gt; <span class="hljs-function">(<span class="hljs-params">next</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">action</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">group</span>(action.<span class="hljs-property">type</span>)
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&#x27;dispatching&#x27;</span>, action)
  <span class="hljs-keyword">let</span> result = <span class="hljs-title function_">next</span>(action)
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;next state&#x27;</span>, store.<span class="hljs-title function_">getState</span>())
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">groupEnd</span>(action.<span class="hljs-property">type</span>)
  <span class="hljs-keyword">return</span> result
}
<span class="hljs-keyword">const</span> initState = {
  <span class="hljs-attr">num</span>: <span class="hljs-number">0</span>,
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">counter</span>(<span class="hljs-params">state = initState, action</span>) {
  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ADD_NUM1&#x27;</span>:
      <span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">num</span>: state.<span class="hljs-property">num</span> + <span class="hljs-number">1</span> }
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">return</span> state
  }
}
<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(counter, <span class="hljs-title function_">applyMiddleware</span>(logger))
store.<span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ADD_NUM1&#x27;</span> })
store.<span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ADD_NUM1&#x27;</span> })
</code></pre>
<p>我们可以看到 applyMiddleware(logger)是当做第参数传入到 createStore 里的，所以我们回顾一下 createStore</p>
<pre class="hljs"><code>  <span class="hljs-title function_">createStore</span>(<span class="hljs-params">reducer, preloadedState, enhancer</span>) {
    ...
    ...
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> enhancer !== <span class="hljs-string">&#x27;undefined&#x27;</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> enhancer !== <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Expected the enhancer to be a function.&#x27;</span>)
      }
      <span class="hljs-comment">// 关键在这里</span>
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">enhancer</span>(createStore)(reducer, preloadedState)
    }
    ...
    ...
  }
</code></pre>
<p>enhancer 就是我们传入 applyMiddleware(logger)，所以接下来的思路就是看一下 applyMiddleware(logger)返回值，这个时候我们就要看一下 applyMiddleware 的源码是怎样实现的了</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> compose <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./compose&#x27;</span>
<span class="hljs-comment">/**
 * 接收的参数就是我们传入的中间件，并且使用解构运算将传入多个中间件转换为数组的形式
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">applyMiddleware</span>(<span class="hljs-params">...middlewares</span>) {
  <span class="hljs-comment">// 返回值是一个三级的柯里化函数</span>
  <span class="hljs-comment">// 第一级函数调用就是enhancer(createStore)，相当于把创建store的方法传给了applyMiddleware</span>
  <span class="hljs-comment">// 第二级函数调用就是enhancer(createStore)(reducer, preloadedState)，将reducer, preloadedState传给applyMiddleware</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">createStore</span>) =&gt;</span>
    <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
      <span class="hljs-comment">// ...args就是reducer, preloadedState，这里就相当于创建了一个store</span>
      <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(...args)
      <span class="hljs-keyword">let</span> <span class="hljs-title function_">dispatch</span> = (<span class="hljs-params"></span>) =&gt; {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
          <span class="hljs-string">&#x27;Dispatching while constructing your middleware is not allowed. &#x27;</span> +
            <span class="hljs-string">&#x27;Other middleware would not be applied to this dispatch.&#x27;</span>
        )
      }
      <span class="hljs-comment">// 这里就是文档里说的：它只暴露一个 store API 的子集给 middleware：dispatch(action) 和 getState()。</span>
      <span class="hljs-keyword">const</span> middlewareAPI = {
        <span class="hljs-attr">getState</span>: store.<span class="hljs-property">getState</span>,
        <span class="hljs-attr">dispatch</span>: <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(...args),
      }
      <span class="hljs-comment">/**
       * 这是我们传入的中间件
        const logger = store =&gt; next =&gt; action =&gt; {
          console.group(action.type)
          console.info(&#x27;dispatching&#x27;, action)
          let result = next(action)
          console.log(&#x27;next state&#x27;, store.getState())
          console.groupEnd(action.type)
          return result
        }
      */</span>
      <span class="hljs-keyword">const</span> chain = middlewares.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">middleware</span>) =&gt;</span> <span class="hljs-title function_">middleware</span>(middlewareAPI))
      <span class="hljs-comment">/**
       * 经过上面的map遍历调用每一个中间件，得到的chain如下
       * chain = [
           next =&gt; action =&gt; {
            console.group(action.type)
            console.info(&#x27;dispatching&#x27;, action)
            let result = next(action)
            console.log(&#x27;next state&#x27;, middlewareAPI.getState()) // 这里发生了改变
            console.groupEnd(action.type)
            return result
          }
       * ]
      */</span>
      dispatch = <span class="hljs-title function_">compose</span>(...chain)(store.<span class="hljs-property">dispatch</span>)
      <span class="hljs-comment">/**
       * compose(...chain)的作用就是将我们传入的中间件嵌套调用，作用是保证每一个中间的的传入的next参数都是上一个中间件修改后的dispatch，由于我们这里只传入了一个中间件，compose(...chain)结果就是chain[0]
       * dispatch = 
          action =&gt; {
            console.group(action.type)
            console.info(&#x27;dispatching&#x27;, action)
            let result = store.dispatch(action) // 这里发生了改变
            console.log(&#x27;next state&#x27;, middlewareAPI.getState())
            console.groupEnd(action.type)
            return result
          }
      */</span>
      <span class="hljs-keyword">return</span> {
        ...store,
        dispatch,
      }
      <span class="hljs-comment">// 最后将改写后的dispatch返回</span>
    }
}
</code></pre>
<p>applyMiddleware 的源码可谓是短小精悍，但是想要彻底理解他还需要反复琢磨</p>
<h2>6、redux-thunk 的使用和解析</h2>
<p>默认情况下，createStore() 所创建的 Redux store 没有使用 middleware，所以只支持 同步数据流。如果我们想要在 dispatch 的时候发起异步请求，就可以使用像 redux-thunk 或 redux-promise 这样支持异步的 middleware，我们先看下 redux-thunk 是如何使用</p>
<pre class="hljs"><code><span class="hljs-comment">//    ./src/index9.jsx</span>
<span class="hljs-keyword">import</span> { createStore, applyMiddleware } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>
<span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-thunk&#x27;</span>
<span class="hljs-keyword">const</span> initState = {
  <span class="hljs-attr">num</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span>,
}
<span class="hljs-keyword">const</span> <span class="hljs-title function_">logger</span> = (<span class="hljs-params">store</span>) =&gt; <span class="hljs-function">(<span class="hljs-params">next</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">action</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">group</span>(action.<span class="hljs-property">type</span>)
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&#x27;dispatching&#x27;</span>, action)
  <span class="hljs-keyword">let</span> result = <span class="hljs-title function_">next</span>(action)
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;next state&#x27;</span>, store.<span class="hljs-title function_">getState</span>())
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">groupEnd</span>(action.<span class="hljs-property">type</span>)
  <span class="hljs-keyword">return</span> result
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">counter</span>(<span class="hljs-params">state = initState, action</span>) {
  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ADD_NUM1&#x27;</span>:
      <span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">num</span>: state.<span class="hljs-property">num</span> + <span class="hljs-number">1</span> }
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;FETCH_DATA&#x27;</span>:
      <span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">data</span>: action.<span class="hljs-property">data</span> }
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">return</span> state
  }
}
<span class="hljs-comment">// 同时使用了thunk和logger两个中间件</span>
<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(counter, <span class="hljs-title function_">applyMiddleware</span>(thunk, logger))
<span class="hljs-comment">// 异步请求数据的方法</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;im asyncdata&#x27;</span>)
    }, <span class="hljs-number">2000</span>)
  })
}
<span class="hljs-comment">// 这是我们要派发的action，使用了redux-thunk以后，action书写成一个函数，在函数里面dispatch action</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">asyncData</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">dispatch</span>) =&gt;</span> {
    <span class="hljs-title function_">fetchData</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
      <span class="hljs-title function_">dispatch</span>({
        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_DATA&#x27;</span>,
        <span class="hljs-attr">data</span>: res,
      })
    })
  }
}
store.<span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ADD_NUM1&#x27;</span> })
store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">asyncData</span>())
</code></pre>
<p>使用了 redux-thunk 以后，异步请求我们不再简单的 dispatch 一个对象，而是 dispatch 一个函数，为什么会发成这种变化呢，让我们来看一看 redux-thunk 内部究竟发生了什么</p>
<pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">createThunkMiddleware</span>(<span class="hljs-params">extraArgument</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">{ dispatch, getState }</span>) =&gt;</span>
    <span class="hljs-function">(<span class="hljs-params">next</span>) =&gt;</span>
    <span class="hljs-function">(<span class="hljs-params">action</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> action === <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">action</span>(dispatch, getState, extraArgument)
      }
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">next</span>(action)
    }
}
<span class="hljs-keyword">const</span> thunk = <span class="hljs-title function_">createThunkMiddleware</span>()
thunk.<span class="hljs-property">withExtraArgument</span> = createThunkMiddleware
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> thunk
</code></pre>
<p>熟悉了中间件以后，其实再阅读中间件就变得很容易了，上述代码中，真正实现 redux-thunk 的功能的代码就以下这个函数</p>
<pre class="hljs"><code>;<span class="hljs-function">(<span class="hljs-params">action</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> action === <span class="hljs-string">&#x27;function&#x27;</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">action</span>(dispatch, getState, extraArgument)
  }
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">next</span>(action)
}
</code></pre>
<p>如果 dispatch 的是一个对象，那么还是原来的 dispatch，如果 dispatch 的是一个函数，那我们就执行这个函数，再回顾一下我们写的 asyncData 这个函数，执行他的返回值的结果就是在两秒后 dispatch 一个普通的 action，就是这么简单的实现了异步数据流，其实看到这里我们也会发现，如果不引入 redux-thunk 我们也可以自己手动调用 asyncData()(store.dispatch)来发起异步请求，只是 redux-thunk 帮我们优雅的做了处理，并且通过 redux-thunk 处理，还可以完美的兼容 bindActionCreators</p>
<pre class="hljs"><code><span class="hljs-comment">//    ./src/index10.jsx</span>
<span class="hljs-keyword">import</span> { createStore, applyMiddleware, bindActionCreators } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>
<span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-thunk&#x27;</span>
<span class="hljs-keyword">const</span> initState = {
  <span class="hljs-attr">num</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span>,
}
<span class="hljs-keyword">const</span> <span class="hljs-title function_">logger</span> = (<span class="hljs-params">store</span>) =&gt; <span class="hljs-function">(<span class="hljs-params">next</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">action</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">group</span>(action.<span class="hljs-property">type</span>)
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&#x27;dispatching&#x27;</span>, action)
  <span class="hljs-keyword">let</span> result = <span class="hljs-title function_">next</span>(action)
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;next state&#x27;</span>, store.<span class="hljs-title function_">getState</span>())
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">groupEnd</span>(action.<span class="hljs-property">type</span>)
  <span class="hljs-keyword">return</span> result
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">counter</span>(<span class="hljs-params">state = initState, action</span>) {
  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ADD_NUM1&#x27;</span>:
      <span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">num</span>: state.<span class="hljs-property">num</span> + <span class="hljs-number">1</span> }
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;FETCH_DATA&#x27;</span>:
      <span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">data</span>: action.<span class="hljs-property">data</span> }
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">return</span> state
  }
}
<span class="hljs-comment">// 同时使用了thunk和logger两个中间件</span>
<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(counter, <span class="hljs-title function_">applyMiddleware</span>(thunk, logger))
<span class="hljs-comment">// 异步请求数据的方法</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;im asyncdata&#x27;</span>)
    }, <span class="hljs-number">2000</span>)
  })
}
<span class="hljs-comment">// 这是我们要派发的action，使用了redux-thunk以后，action书写成一个函数，在函数里面dispatch action</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">asyncData</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">dispatch</span>) =&gt;</span> {
    <span class="hljs-title function_">fetchData</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
      <span class="hljs-title function_">dispatch</span>({
        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_DATA&#x27;</span>,
        <span class="hljs-attr">data</span>: res,
      })
    })
  }
}
<span class="hljs-keyword">const</span> <span class="hljs-title function_">addNum1</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ADD_NUM1&#x27;</span>,
  }
}
<span class="hljs-keyword">const</span> boundActionCreators = <span class="hljs-title function_">bindActionCreators</span>(
  {
    asyncData,
    addNum1,
  },
  store.<span class="hljs-property">dispatch</span>
)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(boundActionCreators, <span class="hljs-string">&#x27;boundActionCreators&#x27;</span>)
boundActionCreators.<span class="hljs-title function_">asyncData</span>()
boundActionCreators.<span class="hljs-title function_">addNum1</span>()
</code></pre>
<p>到这里，整个 redux 的源码解析也就完成了。</p>
</article><div class="Footer_footer__316w0"><div class="Footer_footerInfo__Oa_Q4"><a href="https://github.com/zlqxk/awesome-blog">Github</a></div><div class="Footer_footerPvUv__YWOzD" id="busuanzi_container_site_pv"><p>本站总访问量<span id="busuanzi_value_site_pv"></span>次</p><p>访客数<span id="busuanzi_value_site_uv"></span>人次</p></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/article/redux-source-code","query":{},"buildId":"E-yMlcZOffAX6cd0TJKvF","nextExport":true,"autoExport":true,"isFallback":false,"scriptLoader":[]}</script></body></html>