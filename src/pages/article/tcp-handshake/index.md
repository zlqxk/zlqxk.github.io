# TCP 三次握手

6 月 7, 2022 • ☕️☕️☕️ 10 min read

本文将通过 WiresShark 抓包来详细看下 TCP 三次握手的过程。

![all_handshake](/tcp-handshake/all_handshake.jpg)

## 第一次

客户端向服务端发送了一条 SYN 报文。同时携带序列号 Seq = 0。

![first](/tcp-handshake/first.jpg)

## 第二次

服务端向客户端发送了一条 SYN、ACK 报文。同时携带序列号 Seq = 0 和对上一个报文的确认字段 Ack = 1，代表的是 Seq = 1 之前的报文都接收到了。

![second](/tcp-handshake/second.jpg)

## 第三次

客户端向服务端发送了一条 ACK 报文。同时携带序列号 Seq = 1 和对上一个报文的确认字段 Ack = 1。

![third](/tcp-handshake/third.jpg)

到这里 Tcp 三次握手就结束了，通信双方已经建立了可靠连接，让我们看一个经典问题，为什么需要三次握手？

## 为什么需要三次握手

TCP 作为一个可靠的传输协议，其核心就是保证数据可靠传输，又要提高传输效率。设计成三次握手的主要原因是为了防止旧的重复的连接引起连接混乱的问题。举个例子，在一个很差的网络环境下，客户端发起了一个连接请求，但是在某个网络节点滞留了，一直延误到连接释放后才到达服务端，这个时候服务端以为客户端又要与其发起连接，于是回应了一个 ACK 报文。如果没有三次握手，服务端在发送了这个 ACK 报文后就会建立链接，等待客户端发送数据。但是客户端并未发起连接请求，也不会向服务端发送请求，于是服务端就这样一直等待客户端发送消息，白白浪费服务端的资源。
